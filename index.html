<!DOCTYPE html>
<html lang="uk">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>–ö–∞–º–µ—Ä–∞ (Broadcaster)</title>
  </head>
  <body>
    <video id="localVideo" autoplay playsinline></video>
    <textarea id="logOutput" rows="10" cols="50" readonly></textarea>
    <script>
      const logs = [];
      const originalConsoleLog = console.log;
      console.log = function (message) {
        logs.push(message);
        originalConsoleLog.apply(console, arguments);
        document.getElementById("logOutput").value = logs.join("\n");
      };

      let socket;
      let stream;
      const peerConnections = new Map(); // Map –¥–ª—è –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è viewerId -> RTCPeerConnection
      const iceCandidateQueues = new Map(); // Map –¥–ª—è —á–µ—Ä–≥ ICE –∫–∞–Ω–¥–∏–¥–∞—Ç—ñ–≤
      let offerIntervals = new Map(); // Map –¥–ª—è —ñ–Ω—Ç–µ—Ä–≤–∞–ª—ñ–≤ offer

      const startStream = async () => {
        try {
          if (stream) {
            stream.getTracks().forEach((track) => track.stop());
          }
          stream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: false,
          });
          console.log("‚úÖ –í—ñ–¥–µ–æ –∑ –∫–∞–º–µ—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–æ");
          const videoElement = document.getElementById("localVideo");
          videoElement.srcObject = stream;

          if (socket && socket.readyState === WebSocket.OPEN) socket.close();
          socket = new WebSocket("wss://9078-91-218-88-220.ngrok-free.app");

          socket.onopen = () => {
            console.log("‚úÖ WebSocket –ø—ñ–¥–∫–ª—é—á–µ–Ω–æ");
            socket.send(JSON.stringify({ role: "broadcaster" }));
          };

          socket.onmessage = async (event) => {
            try {
              const message = JSON.parse(event.data);
              console.log("üì© –û—Ç—Ä–∏–º–∞–Ω–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è:", message);

              if (message.newViewer) {
                const viewerId = message.newViewer;
                const pc = new RTCPeerConnection({
                  iceServers: [
                    { urls: "stun:stun.l.google.com:19302" },
                    {
                      urls: "turn:openrelay.metered.ca:80",
                      username: "openrelayproject",
                      credential: "openrelayproject",
                    },
                  ],
                });
                peerConnections.set(viewerId, pc);
                iceCandidateQueues.set(viewerId, []);

                stream
                  .getTracks()
                  .forEach((track) => pc.addTrack(track, stream));
                console.log(
                  `üé• –¢—Ä–µ–∫–∏ –¥–æ–¥–∞–Ω—ñ –¥–æ PeerConnection –¥–ª—è –≥–ª—è–¥–∞—á–∞ ${viewerId}`
                );

                pc.onicecandidate = (event) => {
                  if (event.candidate && socket.readyState === WebSocket.OPEN) {
                    socket.send(
                      JSON.stringify({
                        iceCandidate: event.candidate,
                        viewerId,
                      })
                    );
                    console.log(
                      `üßä –ù–∞–¥—ñ—Å–ª–∞–Ω–æ ICE candidate –¥–ª—è ${viewerId}:`,
                      event.candidate
                    );
                  }
                };

                pc.oniceconnectionstatechange = () => {
                  console.log(
                    `üßä ICE Connection State –¥–ª—è ${viewerId}:`,
                    pc.iceConnectionState
                  );
                  if (pc.iceConnectionState === "disconnected") {
                    console.warn(`‚ö†Ô∏è –ó‚Äô—î–¥–Ω–∞–Ω–Ω—è –∑ ${viewerId} —Ä–æ–∑—ñ—Ä–≤–∞–Ω–æ`);
                  }
                };

                const sendOffer = async () => {
                  try {
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    if (socket.readyState === WebSocket.OPEN) {
                      socket.send(JSON.stringify({ offer, viewerId }));
                      console.log(`üé• –ù–∞–¥—ñ—Å–ª–∞–Ω–æ offer –¥–ª—è ${viewerId}:`, offer);
                    }
                  } catch (error) {
                    console.error(
                      `‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—ñ offer –¥–ª—è ${viewerId}:`,
                      error
                    );
                  }
                };

                await sendOffer();
                offerIntervals.set(
                  viewerId,
                  setInterval(() => {
                    if (
                      !pc.remoteDescription &&
                      pc.iceConnectionState !== "connected" &&
                      pc.iceConnectionState !== "completed"
                    ) {
                      sendOffer();
                    } else if (pc.remoteDescription) {
                      clearInterval(offerIntervals.get(viewerId));
                      console.log(`üõë –ó—É–ø–∏–Ω–µ–Ω–æ –ø–æ–≤—Ç–æ—Ä offer –¥–ª—è ${viewerId}`);
                    }
                  }, 5000)
                );
              } else if (message.answer && message.viewerId) {
                const pc = peerConnections.get(message.viewerId);
                if (pc && pc.signalingState === "have-local-offer") {
                  await pc.setRemoteDescription(
                    new RTCSessionDescription(message.answer)
                  );
                  console.log(
                    `‚úÖ –û—Ç—Ä–∏–º–∞–Ω–æ —ñ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ answer –¥–ª—è ${message.viewerId}`
                  );
                  const queue = iceCandidateQueues.get(message.viewerId);
                  while (queue.length) {
                    const candidate = queue.shift();
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log(
                      `üßä –î–æ–¥–∞–Ω–æ ICE candidate –∑ —á–µ—Ä–≥–∏ –¥–ª—è ${message.viewerId}`
                    );
                  }
                }
              } else if (message.iceCandidate && message.viewerId) {
                const pc = peerConnections.get(message.viewerId);
                if (pc) {
                  if (pc.remoteDescription) {
                    await pc.addIceCandidate(
                      new RTCIceCandidate(message.iceCandidate)
                    );
                    console.log(
                      `üßä –î–æ–¥–∞–Ω–æ ICE candidate –¥–ª—è ${message.viewerId}`
                    );
                  } else {
                    iceCandidateQueues
                      .get(message.viewerId)
                      .push(message.iceCandidate);
                    console.log(
                      `üßä ICE candidate –¥–æ–¥–∞–Ω–æ –≤ —á–µ—Ä–≥—É –¥–ª—è ${message.viewerId}`
                    );
                  }
                }
              } else if (message.viewerDisconnected) {
                const viewerId = message.viewerDisconnected;
                const pc = peerConnections.get(viewerId);
                if (pc) pc.close();
                peerConnections.delete(viewerId);
                iceCandidateQueues.delete(viewerId);
                if (offerIntervals.get(viewerId)) {
                  clearInterval(offerIntervals.get(viewerId));
                  offerIntervals.delete(viewerId);
                }
                console.log(`üóëÔ∏è –í–∏–¥–∞–ª–µ–Ω–æ –∑‚Äô—î–¥–Ω–∞–Ω–Ω—è –¥–ª—è –≥–ª—è–¥–∞—á–∞ ${viewerId}`);
              } else if (message.restart) {
                console.log("üîÑ –û—Ç—Ä–∏–º–∞–Ω–æ –∫–æ–º–∞–Ω–¥—É –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫—É");
                peerConnections.forEach((pc) => pc.close());
                peerConnections.clear();
                iceCandidateQueues.clear();
                offerIntervals.forEach((interval) => clearInterval(interval));
                offerIntervals.clear();
                await startStream();
              }
            } catch (error) {
              console.error("‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è:", error);
            }
          };

          socket.onerror = (error) => {
            console.error("‚ùå –ü–æ–º–∏–ª–∫–∞ WebSocket:", error);
          };

          socket.onclose = () => {
            console.log("‚ö†Ô∏è WebSocket –∑–∞–∫—Ä–∏—Ç–æ");
          };
        } catch (error) {
          console.error("‚ùå –ü–æ–º–∏–ª–∫–∞ –¥–æ—Å—Ç—É–ø—É –¥–æ –∫–∞–º–µ—Ä–∏ –∞–±–æ WebRTC:", error);
        }
      };

      startStream();

      window.onunload = () => {
        if (socket && socket.readyState === WebSocket.OPEN) socket.close();
        peerConnections.forEach((pc) => pc.close());
        if (stream) stream.getTracks().forEach((track) => track.stop());
        offerIntervals.forEach((interval) => clearInterval(interval));
        console.log("üõë –†–µ—Å—É—Ä—Å–∏ –æ—á–∏—â–µ–Ω–æ");
      };
    </script>
  </body>
</html>
