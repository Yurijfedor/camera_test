<!DOCTYPE html>
<html lang="uk">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>–ö–∞–º–µ—Ä–∞ (Broadcaster)</title>
  </head>
  <body>
    <video id="localVideo" autoplay playsinline></video>
    <script>
      const startStream = async () => {
        let socket;
        let peerConnection;
        let stream;
        const iceCandidateQueue = [];
        let offerInterval;

        try {
          // –û—Ç—Ä–∏–º—É—î–º–æ –º–µ–¥—ñ–∞–ø–æ—Ç—ñ–∫
          stream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: false,
          });
          const videoElement = document.getElementById("localVideo");
          videoElement.srcObject = stream;
          console.log("‚úÖ –í—ñ–¥–µ–æ –∑ –∫–∞–º–µ—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–æ");

          // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è WebRTC
          peerConnection = new RTCPeerConnection({
            iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
          });
          stream
            .getTracks()
            .forEach((track) => peerConnection.addTrack(track, stream));
          console.log("üé• –¢—Ä–µ–∫–∏ –¥–æ–¥–∞–Ω—ñ –¥–æ PeerConnection");

          // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è WebSocket
          socket = new WebSocket("wss://192.168.0.103:8080");

          const sendOffer = async () => {
            try {
              const offer = await peerConnection.createOffer();
              await peerConnection.setLocalDescription(offer);
              if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ offer }));
                console.log("üé• –ù–∞–¥—ñ—Å–ª–∞–Ω–æ offer:", offer);
              }
            } catch (error) {
              console.error("‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—ñ offer:", error);
            }
          };

          socket.onopen = async () => {
            console.log("‚úÖ WebSocket –ø—ñ–¥–∫–ª—é—á–µ–Ω–æ");
            socket.send(JSON.stringify({ role: "broadcaster" }));
            await sendOffer();

            // –ü–æ–≤—Ç–æ—Ä—é—î–º–æ offer –∫–æ–∂–Ω—ñ 5 —Å–µ–∫—É–Ω–¥, —è–∫—â–æ –∑'—î–¥–Ω–∞–Ω–Ω—è –Ω–µ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ
            offerInterval = setInterval(() => {
              if (
                peerConnection.iceConnectionState !== "connected" &&
                peerConnection.iceConnectionState !== "completed"
              ) {
                sendOffer();
              } else {
                clearInterval(offerInterval);
                console.log("üõë –ó—É–ø–∏–Ω–µ–Ω–æ –ø–æ–≤—Ç–æ—Ä offer: –∑'—î–¥–Ω–∞–Ω–Ω—è –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ");
              }
            }, 5000);
          };

          socket.onmessage = async (event) => {
            try {
              const message = JSON.parse(event.data);
              console.log("üì© –û—Ç—Ä–∏–º–∞–Ω–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è:", message);

              if (message.offer) {
                console.warn("‚ö†Ô∏è –û—Ç—Ä–∏–º–∞–Ω–æ –Ω–µ–æ—á—ñ–∫—É–≤–∞–Ω–∏–π offer, —ñ–≥–Ω–æ—Ä—É—î–º–æ");
                return;
              } else if (message.answer) {
                await peerConnection.setRemoteDescription(
                  new RTCSessionDescription(message.answer)
                );
                console.log("‚úÖ –û—Ç—Ä–∏–º–∞–Ω–æ —ñ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ answer");
                while (iceCandidateQueue.length) {
                  const candidate = iceCandidateQueue.shift();
                  await peerConnection.addIceCandidate(
                    new RTCIceCandidate(candidate)
                  );
                  console.log("üßä –î–æ–¥–∞–Ω–æ ICE candidate –∑ —á–µ—Ä–≥–∏:", candidate);
                }
              } else if (message.iceCandidate) {
                if (peerConnection.remoteDescription) {
                  await peerConnection.addIceCandidate(
                    new RTCIceCandidate(message.iceCandidate)
                  );
                  console.log("üßä –î–æ–¥–∞–Ω–æ ICE candidate:", message.iceCandidate);
                } else {
                  iceCandidateQueue.push(message.iceCandidate);
                  console.log(
                    "üßä ICE candidate –¥–æ–¥–∞–Ω–æ –≤ —á–µ—Ä–≥—É:",
                    message.iceCandidate
                  );
                }
              }
            } catch (error) {
              console.error("‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è:", error);
            }
          };

          socket.onerror = (error) => {
            console.error("‚ùå –ü–æ–º–∏–ª–∫–∞ WebSocket:", error);
          };

          socket.onclose = () => {
            console.log("‚ö†Ô∏è WebSocket –∑–∞–∫—Ä–∏—Ç–æ");
          };

          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ iceCandidate: event.candidate }));
                console.log("üßä –ù–∞–¥—ñ—Å–ª–∞–Ω–æ ICE candidate:", event.candidate);
              }
            }
          };

          peerConnection.oniceconnectionstatechange = () => {
            console.log(
              "üßä ICE Connection State:",
              peerConnection.iceConnectionState
            );
          };
        } catch (error) {
          console.error("‚ùå –ü–æ–º–∏–ª–∫–∞ –¥–æ—Å—Ç—É–ø—É –¥–æ –∫–∞–º–µ—Ä–∏ –∞–±–æ WebRTC:", error);
        }

        window.onunload = () => {
          if (socket && socket.readyState === WebSocket.OPEN) socket.close();
          if (peerConnection) peerConnection.close();
          if (stream) stream.getTracks().forEach((track) => track.stop());
          if (offerInterval) clearInterval(offerInterval);
          console.log("üõë –†–µ—Å—É—Ä—Å–∏ –æ—á–∏—â–µ–Ω–æ");
        };
      };

      startStream();
    </script>
  </body>
</html>
