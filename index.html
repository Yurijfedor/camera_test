<!DOCTYPE html>
<html lang="uk">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>–ö–∞–º–µ—Ä–∞ (Broadcaster)</title>
  </head>
  <body>
    <video id="localVideo" autoplay playsinline></video>
    <script>
      const startStream = async () => {
        let socket;
        let peerConnection;
        const iceCandidateQueue = []; // –ß–µ—Ä–≥–∞ –¥–ª—è ICE –∫–∞–Ω–¥–∏–¥–∞—Ç—ñ–≤

        try {
          // –û—Ç—Ä–∏–º—É—î–º–æ –º–µ–¥—ñ–∞–ø–æ—Ç—ñ–∫
          const stream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: false,
          });
          const videoElement = document.getElementById("localVideo");
          videoElement.srcObject = stream;
          console.log("‚úÖ –í—ñ–¥–µ–æ –∑ –∫–∞–º–µ—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–æ");

          // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è WebRTC
          peerConnection = new RTCPeerConnection({
            iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
          });
          stream
            .getTracks()
            .forEach((track) => peerConnection.addTrack(track, stream));
          console.log("üé• –¢—Ä–µ–∫–∏ –¥–æ–¥–∞–Ω—ñ –¥–æ PeerConnection");

          // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è WebSocket
          socket = new WebSocket("wss://192.168.0.103:8080");

          socket.onopen = async () => {
            console.log("‚úÖ WebSocket –ø—ñ–¥–∫–ª—é—á–µ–Ω–æ");
            socket.send(JSON.stringify({ role: "broadcaster" }));

            try {
              const offer = await peerConnection.createOffer();
              await peerConnection.setLocalDescription(offer);
              if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ offer }));
                console.log("üé• –ù–∞–¥—ñ—Å–ª–∞–Ω–æ offer:", offer);
              }
            } catch (error) {
              console.error("‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—ñ offer:", error);
            }
          };

          socket.onmessage = async (event) => {
            try {
              const message = JSON.parse(event.data);
              console.log("üì© –û—Ç—Ä–∏–º–∞–Ω–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è:", message);

              if (message.offer) {
                console.warn("‚ö†Ô∏è –û—Ç—Ä–∏–º–∞–Ω–æ –Ω–µ–æ—á—ñ–∫—É–≤–∞–Ω–∏–π offer, —ñ–≥–Ω–æ—Ä—É—î–º–æ");
                return; // Broadcaster –Ω–µ –ø–æ–≤–∏–Ω–µ–Ω –æ–±—Ä–æ–±–ª—è—Ç–∏ offer
              } else if (message.answer) {
                await peerConnection.setRemoteDescription(
                  new RTCSessionDescription(message.answer)
                );
                console.log("‚úÖ –û—Ç—Ä–∏–º–∞–Ω–æ —ñ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ answer");

                // –û–±—Ä–æ–±–∫–∞ ICE –∫–∞–Ω–¥–∏–¥–∞—Ç—ñ–≤ —ñ–∑ —á–µ—Ä–≥–∏
                while (iceCandidateQueue.length) {
                  const candidate = iceCandidateQueue.shift();
                  await peerConnection.addIceCandidate(
                    new RTCIceCandidate(candidate)
                  );
                  console.log("üßä –î–æ–¥–∞–Ω–æ ICE candidate –∑ —á–µ—Ä–≥–∏:", candidate);
                }
              } else if (message.iceCandidate) {
                if (peerConnection.remoteDescription) {
                  await peerConnection.addIceCandidate(
                    new RTCIceCandidate(message.iceCandidate)
                  );
                  console.log("üßä –î–æ–¥–∞–Ω–æ ICE candidate:", message.iceCandidate);
                } else {
                  iceCandidateQueue.push(message.iceCandidate);
                  console.log(
                    "üßä ICE candidate –¥–æ–¥–∞–Ω–æ –≤ —á–µ—Ä–≥—É:",
                    message.iceCandidate
                  );
                }
              }
            } catch (error) {
              console.error("‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è:", error);
            }
          };

          socket.onerror = (error) => {
            console.error("‚ùå –ü–æ–º–∏–ª–∫–∞ WebSocket:", error);
          };

          socket.onclose = () => {
            console.log("‚ö†Ô∏è WebSocket –∑–∞–∫—Ä–∏—Ç–æ");
          };

          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ iceCandidate: event.candidate }));
                console.log("üßä –ù–∞–¥—ñ—Å–ª–∞–Ω–æ ICE candidate:", event.candidate);
              }
            }
          };

          peerConnection.oniceconnectionstatechange = () => {
            console.log(
              "üßä ICE Connection State:",
              peerConnection.iceConnectionState
            );
          };
        } catch (error) {
          console.error("‚ùå –ü–æ–º–∏–ª–∫–∞ –¥–æ—Å—Ç—É–ø—É –¥–æ –∫–∞–º–µ—Ä–∏ –∞–±–æ WebRTC:", error);
        }

        window.onunload = () => {
          if (socket && socket.readyState === WebSocket.OPEN) socket.close();
          if (peerConnection) peerConnection.close();
          if (stream) stream.getTracks().forEach((track) => track.stop());
          console.log("üõë –†–µ—Å—É—Ä—Å–∏ –æ—á–∏—â–µ–Ω–æ");
        };
      };

      startStream();
    </script>
  </body>
</html>
