<!DOCTYPE html>
<html lang="uk">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>–ö–∞–º–µ—Ä–∞ (Broadcaster)</title>
  </head>
  <body>
    <video id="localVideo" autoplay playsinline></video>
    <script>
      const startStream = async () => {
        let socket;
        let peerConnection;
        let stream;
        const iceCandidateQueue = [];
        let offerInterval;

        try {
          stream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: false,
          });
          console.log("‚úÖ –í—ñ–¥–µ–æ –∑ –∫–∞–º–µ—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–æ");
          const videoElement = document.getElementById("localVideo");
          videoElement.srcObject = stream;

          peerConnection = new RTCPeerConnection({
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              {
                urls: "turn:openrelay.metered.ca:80",
                username: "openrelayproject",
                credential: "openrelayproject",
              },
            ],
          });
          stream
            .getTracks()
            .forEach((track) => peerConnection.addTrack(track, stream));
          console.log("üé• –¢—Ä–µ–∫–∏ –¥–æ–¥–∞–Ω—ñ –¥–æ PeerConnection");

          socket = new WebSocket("wss://9078-91-218-88-220.ngrok-free.app");

          const sendOffer = async () => {
            try {
              const offer = await peerConnection.createOffer();
              await peerConnection.setLocalDescription(offer);
              if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ offer }));
                console.log("üé• –ù–∞–¥—ñ—Å–ª–∞–Ω–æ offer:", offer);
              }
            } catch (error) {
              console.error("‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—ñ offer:", error);
            }
          };

          socket.onopen = async () => {
            console.log("‚úÖ WebSocket –ø—ñ–¥–∫–ª—é—á–µ–Ω–æ");
            socket.send(JSON.stringify({ role: "broadcaster" }));
            await sendOffer();

            offerInterval = setInterval(() => {
              if (
                !peerConnection.remoteDescription &&
                peerConnection.iceConnectionState !== "connected" &&
                peerConnection.iceConnectionState !== "completed"
              ) {
                sendOffer();
              } else if (peerConnection.remoteDescription) {
                clearInterval(offerInterval);
                console.log("üõë –ó—É–ø–∏–Ω–µ–Ω–æ –ø–æ–≤—Ç–æ—Ä offer: answer –æ—Ç—Ä–∏–º–∞–Ω–æ");
              }
            }, 5000);
          };

          socket.onmessage = async (event) => {
            try {
              const message = JSON.parse(event.data);
              console.log("üì© –û—Ç—Ä–∏–º–∞–Ω–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è:", message);

              if (message.offer) {
                console.warn("‚ö†Ô∏è –û—Ç—Ä–∏–º–∞–Ω–æ –Ω–µ–æ—á—ñ–∫—É–≤–∞–Ω–∏–π offer, —ñ–≥–Ω–æ—Ä—É—î–º–æ");
                return;
              } else if (message.answer) {
                const signalingState = peerConnection.signalingState;
                console.log("–¢–µ–∫—É—â–∏–π —Å—Ç–∞–Ω —Å–∏–≥–Ω–∞–ª—ñ–∑–∞—Ü—ñ—ó:", signalingState);

                if (signalingState === "have-local-offer") {
                  await peerConnection.setRemoteDescription(
                    new RTCSessionDescription(message.answer)
                  );
                  console.log("‚úÖ –û—Ç—Ä–∏–º–∞–Ω–æ —ñ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ answer");
                  while (iceCandidateQueue.length) {
                    const candidate = iceCandidateQueue.shift();
                    await peerConnection.addIceCandidate(
                      new RTCIceCandidate(candidate)
                    );
                    console.log("üßä –î–æ–¥–∞–Ω–æ ICE candidate –∑ —á–µ—Ä–≥–∏:", candidate);
                  }
                } else if (signalingState === "stable") {
                  console.warn(
                    "‚ö†Ô∏è Answer –æ—Ç—Ä–∏–º–∞–Ω–æ –≤ —Å—Ç–∞–Ω—ñ stable, –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞—î–º–æ"
                  );
                  await sendOffer();
                }
              } else if (message.iceCandidate) {
                if (peerConnection.remoteDescription) {
                  await peerConnection.addIceCandidate(
                    new RTCIceCandidate(message.iceCandidate)
                  );
                  console.log("üßä –î–æ–¥–∞–Ω–æ ICE candidate:", message.iceCandidate);
                } else {
                  iceCandidateQueue.push(message.iceCandidate);
                  console.log(
                    "üßä ICE candidate –¥–æ–¥–∞–Ω–æ –≤ —á–µ—Ä–≥—É:",
                    message.iceCandidate
                  );
                }
              }
            } catch (error) {
              console.error("‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è:", error);
            }
          };

          socket.onerror = (error) => {
            console.error("‚ùå –ü–æ–º–∏–ª–∫–∞ WebSocket:", error);
          };

          socket.onclose = () => {
            console.log("‚ö†Ô∏è WebSocket –∑–∞–∫—Ä–∏—Ç–æ");
          };

          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ iceCandidate: event.candidate }));
                console.log("üßä –ù–∞–¥—ñ—Å–ª–∞–Ω–æ ICE candidate:", event.candidate);
              }
            }
          };

          peerConnection.oniceconnectionstatechange = () => {
            console.log(
              "üßä ICE Connection State:",
              peerConnection.iceConnectionState
            );
            if (peerConnection.iceConnectionState === "disconnected") {
              console.warn("‚ö†Ô∏è –ó‚Äô—î–¥–Ω–∞–Ω–Ω—è —Ä–æ–∑—ñ—Ä–≤–∞–Ω–æ, –ø–æ–≤—Ç–æ—Ä—é—î–º–æ offer");
              sendOffer();
            }
          };
        } catch (error) {
          console.error("‚ùå –ü–æ–º–∏–ª–∫–∞ –¥–æ—Å—Ç—É–ø—É –¥–æ –∫–∞–º–µ—Ä–∏ –∞–±–æ WebRTC:", error);
        }

        window.onunload = () => {
          if (socket && socket.readyState === WebSocket.OPEN) socket.close();
          if (peerConnection) peerConnection.close();
          if (stream) stream.getTracks().forEach((track) => track.stop());
          if (offerInterval) clearInterval(offerInterval);
          console.log("üõë –†–µ—Å—É—Ä—Å–∏ –æ—á–∏—â–µ–Ω–æ");
        };
      };

      startStream();
    </script>
  </body>
</html>
