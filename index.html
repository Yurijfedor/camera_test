<!DOCTYPE html>
<html lang="uk">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>–ö–∞–º–µ—Ä–∞ (Broadcaster)</title>
  </head>
  <body>
    <video id="localVideo" autoplay playsinline muted></video>
    <textarea id="logOutput" rows="10" cols="50" readonly></textarea>
    <button onclick="startStream()">Restart Stream</button>
    <script>
      const logs = [];
      const originalConsoleLog = console.log;
      console.log = function (message) {
        logs.push(message);
        originalConsoleLog.apply(console, arguments);
        document.getElementById("logOutput").value = logs.join("\n");
      };

      let socket;
      let peerConnection;
      let stream;
      let iceCandidateQueue = [];
      let offerInterval;

      const startStream = async () => {
        try {
          // –ó—É–ø–∏–Ω—è—î–º–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π –ø–æ—Ç—ñ–∫, —è–∫—â–æ –≤—ñ–Ω —î
          if (stream) {
            stream.getTracks().forEach((track) => track.stop());
          }

          // –ó–∞—Ö–æ–ø–ª–µ–Ω–Ω—è –µ–∫—Ä–∞–Ω—É –∑–∞–º—ñ—Å—Ç—å –≤–µ–±-–∫–∞–º–µ—Ä–∏
          stream = await navigator.mediaDevices.getDisplayMedia({
            video: true,
            audio: false, // –î–æ–¥–∞–π—Ç–µ audio: true, —è–∫—â–æ –ø–æ—Ç—Ä—ñ–±–µ–Ω –∑–≤—É–∫
          });
          console.log("‚úÖ –ï–∫—Ä–∞–Ω –∑–∞—Ö–æ–ø–ª–µ–Ω–æ");
          const videoElement = document.getElementById("localVideo");
          videoElement.srcObject = stream;

          // –ó–∞–∫—Ä–∏—Ç—Ç—è –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ–≥–æ –∑‚Äô—î–¥–Ω–∞–Ω–Ω—è
          if (peerConnection) peerConnection.close();
          peerConnection = new RTCPeerConnection({
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              {
                urls: "turn:openrelay.metered.ca:80",
                username: "openrelayproject",
                credential: "openrelayproject",
              },
            ],
          });

          // –î–æ–¥–∞—î–º–æ —Ç—Ä–µ–∫–∏ –¥–æ WebRTC
          stream
            .getTracks()
            .forEach((track) => peerConnection.addTrack(track, stream));
          console.log("üé• –¢—Ä–µ–∫–∏ –¥–æ–¥–∞–Ω—ñ –¥–æ PeerConnection");

          // –ó–∞–∫—Ä–∏–≤–∞—î–º–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π WebSocket, —è–∫—â–æ –≤—ñ–¥–∫—Ä–∏—Ç–∏–π
          if (socket && socket.readyState === WebSocket.OPEN) socket.close();
          socket = new WebSocket("ws://localhost:8080"); // –ó–º—ñ–Ω—ñ—Ç—å –Ω–∞ –≤–∞—à –ª–æ–∫–∞–ª—å–Ω–∏–π —Å–µ—Ä–≤–µ—Ä

          const sendOffer = async () => {
            try {
              const offer = await peerConnection.createOffer();
              await peerConnection.setLocalDescription(offer);
              if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ offer }));
                console.log("üé• –ù–∞–¥—ñ—Å–ª–∞–Ω–æ offer:", offer);
              }
            } catch (error) {
              console.error("‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—ñ offer:", error);
            }
          };

          socket.onopen = async () => {
            console.log("‚úÖ WebSocket –ø—ñ–¥–∫–ª—é—á–µ–Ω–æ");
            socket.send(JSON.stringify({ role: "broadcaster" }));
            await sendOffer();

            if (offerInterval) clearInterval(offerInterval);
            offerInterval = setInterval(() => {
              if (
                !peerConnection.remoteDescription &&
                peerConnection.iceConnectionState !== "connected" &&
                peerConnection.iceConnectionState !== "completed"
              ) {
                sendOffer();
              } else if (peerConnection.remoteDescription) {
                clearInterval(offerInterval);
                console.log("üõë –ó—É–ø–∏–Ω–µ–Ω–æ –ø–æ–≤—Ç–æ—Ä offer: answer –æ—Ç—Ä–∏–º–∞–Ω–æ");
              }
            }, 5000);
          };

          socket.onmessage = async (event) => {
            try {
              const message = JSON.parse(event.data);
              console.log("üì© –û—Ç—Ä–∏–º–∞–Ω–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è:", message);

              if (message.restart) {
                console.log("üîÑ –û—Ç—Ä–∏–º–∞–Ω–æ –∫–æ–º–∞–Ω–¥—É –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫—É");
                if (offerInterval) clearInterval(offerInterval);
                iceCandidateQueue = [];
                await startStream();
                return;
              }

              if (message.offer) {
                console.warn("‚ö†Ô∏è –û—Ç—Ä–∏–º–∞–Ω–æ –Ω–µ–æ—á—ñ–∫—É–≤–∞–Ω–∏–π offer, —ñ–≥–Ω–æ—Ä—É—î–º–æ");
                return;
              } else if (message.answer) {
                const signalingState = peerConnection.signalingState;
                console.log("–¢–µ–∫—É—â–∏–π —Å—Ç–∞–Ω —Å–∏–≥–Ω–∞–ª—ñ–∑–∞—Ü—ñ—ó:", signalingState);

                if (signalingState === "have-local-offer") {
                  await peerConnection.setRemoteDescription(
                    new RTCSessionDescription(message.answer)
                  );
                  console.log("‚úÖ –û—Ç—Ä–∏–º–∞–Ω–æ —ñ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ answer");
                  while (iceCandidateQueue.length) {
                    const candidate = iceCandidateQueue.shift();
                    await peerConnection.addIceCandidate(
                      new RTCIceCandidate(candidate)
                    );
                    console.log("üßä –î–æ–¥–∞–Ω–æ ICE candidate –∑ —á–µ—Ä–≥–∏:", candidate);
                  }
                } else if (signalingState === "stable") {
                  console.warn(
                    "‚ö†Ô∏è Answer –æ—Ç—Ä–∏–º–∞–Ω–æ –≤ —Å—Ç–∞–Ω—ñ stable, –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞—î–º–æ"
                  );
                  await sendOffer();
                }
              } else if (message.iceCandidate) {
                if (peerConnection.remoteDescription) {
                  await peerConnection.addIceCandidate(
                    new RTCIceCandidate(message.iceCandidate)
                  );
                  console.log("üßä –î–æ–¥–∞–Ω–æ ICE candidate:", message.iceCandidate);
                } else {
                  iceCandidateQueue.push(message.iceCandidate);
                  console.log(
                    "üßä ICE candidate –¥–æ–¥–∞–Ω–æ –≤ —á–µ—Ä–≥—É:",
                    message.iceCandidate
                  );
                }
              }
            } catch (error) {
              console.error("‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è:", error);
            }
          };

          socket.onerror = (error) => {
            console.error("‚ùå –ü–æ–º–∏–ª–∫–∞ WebSocket:", error);
          };

          socket.onclose = () => {
            console.log("‚ö†Ô∏è WebSocket –∑–∞–∫—Ä–∏—Ç–æ");
          };

          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ iceCandidate: event.candidate }));
                console.log("üßä –ù–∞–¥—ñ—Å–ª–∞–Ω–æ ICE candidate:", event.candidate);
              }
            }
          };

          peerConnection.oniceconnectionstatechange = () => {
            console.log(
              "üßä ICE Connection State:",
              peerConnection.iceConnectionState
            );
            if (peerConnection.iceConnectionState === "disconnected") {
              console.warn("‚ö†Ô∏è –ó‚Äô—î–¥–Ω–∞–Ω–Ω—è —Ä–æ–∑—ñ—Ä–≤–∞–Ω–æ, –ø–æ–≤—Ç–æ—Ä—é—î–º–æ offer");
              sendOffer();
            }
          };
        } catch (error) {
          console.error("‚ùå –ü–æ–º–∏–ª–∫–∞ –¥–æ—Å—Ç—É–ø—É –¥–æ –µ–∫—Ä–∞–Ω—É –∞–±–æ WebRTC:", error);
        }
      };

      startStream();

      window.onunload = () => {
        if (socket && socket.readyState === WebSocket.OPEN) socket.close();
        if (peerConnection) peerConnection.close();
        if (stream) stream.getTracks().forEach((track) => track.stop());
        if (offerInterval) clearInterval(offerInterval);
        console.log("üõë –†–µ—Å—É—Ä—Å–∏ –æ—á–∏—â–µ–Ω–æ");
      };
    </script>
  </body>
</html>
